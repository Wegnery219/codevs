# 乘积最大
划分型DP
### 题目描述 Description
设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。

 同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：

 有一个数字串：312， 当N=3，K=1时会有以下两种分法：

1)  3*12=36
2)  31*2=62

这时，符合题目要求的结果是：31*2=62

现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。

### 输入描述 Input Description
   程序的输入共有两行：

   第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）

   第二行是一个长度为N的数字串。

### 输出描述 Output Description
   结果显示在屏幕上，相对于输入，应输出所求得的最大乘积（一个自然数）。

### 样例输入 Sample Input
4  2

1231

### 样例输出 Sample Output
62

### 
数据范围及提示 Data Size & Hint
本题由于比较老，数据实际也比较小，用long long 即可通过
### 解题思路
一开始想用传统动归做，嗯失败了而且很麻烦，然后知道了动态规划有很多种，这种属于划分型DP，每次以一段区间，然后尝试减少一个划分增加到后面的。
`f[j,s]=max{f[j,s],f[l,s-1]*num[l+1,j]}`</br>
意思是从第1个数到第j个数分s段的值等于将到j分s段的值和到i分s-1段，剩下的数直接乘，就相当于枚举乘号的位置。啊哈！机智如我。自底向上。
### 核心代码
```
for (int i = 1; i <= n; i++)
        Maxvalue[i][0] = tonum(1, i);
	for(int j=1;j<=k;j++){
		for(int i=1;i<=n;i++){//i代表截断元素Maxvalue[i][j]含义是1->第i个元素插入j个*号的最大值 
			for(int l=j;l<i;l++){//从j到i，因为要保证符号能放进去 
				Maxvalue[i][j]=max(Maxvalue[i][j],Maxvalue[l][j-1]*tonum(l+1,i));
			}
		}
	}
```