# 分治算法
- 基于一个算法网站上的一些题，本来是按照天梯的顺序做的，后来觉得东一脚西一脚掌握的不牢靠，所以直接按照题目分类进行学习。
### 一.与逆序对有关
#### **逆序对数**</br>
逆序对是指i<j时，a[i]>a[j]的情况，使用归并排序，在归并排序中，既要排序，又要统计逆序对个数，核心代码：
```
while(i<=mid&&j<=end){
		if(temp[i]<=temp[j]){
			ar[k++]=temp[i++];
		}
		else{
			total+=mid-i+1;
			ar[k++]=temp[j++];
		}
	}
```
建立一个临时数组用于拷贝,一个排序，一个统计，归并的时候也一样，如果左边的a[i]>右边的a[j],则由于有序，左边剩下的都大于a[j],所以逆序对数加上mid-i+1。
#### **新斯诺克</br>**
相当于一个基于逆序对数的应用，给一串数，求这一串数中的连续几个，这几个的平均值要大于某个给定值k，首先每个数都减去k，转换成平均值大于0的问题，然后对减去k后得到的这串数求前缀和，举例：`1 2 3 4 -> 1 3 6 10`,原问题转换成求前缀和的顺序对数，如果i<j,a[i]<a[j],说明i+1~j之间的这些数的和大于0，即平均值大于0。</br>
运行中出现了TLE和WA问题，几个原因：
1. 记录顺序对数的变量忘记设置成long long，导致溢出
2. C++中数组比vector要快，scanf比cin要快，用cin的时候记得头文件`<cstdio>`
3. 不是每一遍都需要把所有数组全拷贝
```
//vector<int> temp=sum;//每一步都拷贝所有数组，导致时间变长,tle
for (int i=begin;i<=end;i++) temp[i]=sum[i]; 
```
4. 把起始边界定义成0了，递归中特别注意这一点，应该是begin</br>
*其余错误见代码注释*
#### **火柴排队**
还没AC，困惑是怎么把另一个数组按照a数组交换元素的方式进行交换
### 二.取余运算
算法考试考了取余运算用动归怎么写，当时就不会，做这道题明白了一些。对大数字取余的时候，有个原理`A*B%K = (A%K )*(B% K )%K`这样就可以把较大的数分解成较小的数分而治之。
</br>核心代码：
```
int quyu(long long x){
	if(x==0)return 1;//任何数的0次方模k都等于1 
    long long tmp=quyu(x/2)%k;
    tmp=(tmp*tmp)%k;
    if(x%2==1)tmp=(tmp*b)%k;
    return tmp;
} 
```
TLE的代码：
```
int quyu(int b,int p,int k){
	if(p==0) return 1;
	if(p==1) return b%k; 
	int mid=p/2;
	int res=p-mid;
	int l1=quyu(b,mid,k);
	int l2=quyu(b,res,k);
	int x=(l1*l2)%k;
	return x;
}
```
这种方法可以用动归添加备忘来实现。
### 三.地毯问题
算法老师之前也讲过，给四种形状的地毯，贴地毯，留出一块空白不贴，算法当时懂了，但是实现起来问题还是很多，分治是一个自顶向下的问题，根据空白所在的大方向来确定每个小角落该帖什么，很考验耐心，有空多复习一下代码。