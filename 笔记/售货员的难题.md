# 2596 售货员的难题
售货员不知道难没难到，反正是难到菜鸡我了:)</br>
### 题目描述：
某乡有n个村庄(1<n<＝15)，有一个售货员，他要到各个村庄去售货，各村庄之间的路程s(0<s<1000)是已知的，且A村到B村与B村到A村的路大多不同。为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，假设商店所在的村庄为1，他不知道选择什么样的路线才能使所走的路程最短。请你帮他选择一条最短的路。</br>
</br>
### 痛苦的心路历程= =:</br>
这个题分类本身是出现在最小生成树下，莫非一遍最小生成树再加上最后一个点到开头的距离就OK了？后来想最小生成树不是严格按照从头到尾的顺序啊，pass。spfa?(毕竟菜鸡宁只有这两个最熟)后来想出来一种，正向spfa一遍，然后d[u]+s[1]最小(s[1]是用u逆向spfa之后到1的最短距离)，这不用写就超时了好么。。。而且更何况也没法保证d[u]的时候每个点都访问过了。这可咋整。。。于是机智的我想到了躲避大龙，还有爱情之路，可以建一个数组来记录访问到d[u]的时候经过了几个节点。然并卵，就算没有全经过用这个方法也没法解决啊。。。后来看到了提示，dfs??嗯，于是我就用了dfs，但是多带了一个参数用来记录当前访问了多少个节点。就每一遍都dfs到最深的点，如果全部节点遍历完了，加上最后一个点到1的距离比ans小就松弛，看上去跟我第二个想法很像对不对(强行像2333)，整体思路很简单，核心代码如下：
```
int dfs(int node,int now){
	if(x>=ans) return 0;
	if(now==n){
		if(x+g[node][1]<ans) ans=x+g[node][1];
	}
	else{
		for(int i=1;i<=n;i++){
			if(!vis[i]){
				x=x+g[node][i];
				vis[i]=1;
				dfs(i,now+1);
				x=x-g[node][i];
				vis[i]=0; 
			}	
		}
		
	}
}
```
然而，T!L!E!了。。。今天也是很难受的一天，但是为了不秃顶我要睡了，希望ACM大佬补考完能理理我。晚安。